; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

	TITLE	G:\汇编语言新书实例\MMX指令\ipp_normal_add\sse_normal_mul.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?src1@@3PAMA					; src1
PUBLIC	?src2@@3MA					; src2
PUBLIC	?dst@@3PAMA					; dst
PUBLIC	?len@@3HA					; len
PUBLIC	?epochs@@3HA					; epochs
_BSS	SEGMENT
?src1@@3PAMA DD	0f4241H DUP (?)				; src1
?src2@@3MA DD	01H DUP (?)				; src2
?dst@@3PAMA DD	0f4241H DUP (?)				; dst
_BSS	ENDS
_DATA	SEGMENT
?len@@3HA DD	0f4241H					; len
?epochs@@3HA DD	03e8H					; epochs
_DATA	ENDS
PUBLIC	?sse_mul@@YAXPBMABMPAMH@Z			; sse_mul
PUBLIC	?normal_mul@@YAXPBMABMPAMH@Z			; normal_mul
PUBLIC	_main
PUBLIC	??_C@_09OAKFDBNP@sse?3?5?$CFfs?6?$AA@		; `string'
PUBLIC	??_C@_0N@KANIBBAJ@normal?3?5?$CFfs?6?$AA@	; `string'
PUBLIC	??_C@_0BC@DDHBBFNC@normal?5?1?5sse?5?$DN?5?$CFf?$AA@ ; `string'
PUBLIC	__real@3f50624dd2f1a9fc
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@408f400000000000
EXTRN	__imp__printf:PROC
EXTRN	__imp__clock:PROC
EXTRN	__imp___time64:PROC
EXTRN	__imp__rand:PROC
EXTRN	__imp__srand:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__fltused:DWORD
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3f50624dd2f1a9fc
CONST	SEGMENT
__real@3f50624dd2f1a9fc DQ 03f50624dd2f1a9fcr	; 0.001
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BC@DDHBBFNC@normal?5?1?5sse?5?$DN?5?$CFf?$AA@
CONST	SEGMENT
??_C@_0BC@DDHBBFNC@normal?5?1?5sse?5?$DN?5?$CFf?$AA@ DB 'normal / sse = %'
	DB	'f', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KANIBBAJ@normal?3?5?$CFfs?6?$AA@
CONST	SEGMENT
??_C@_0N@KANIBBAJ@normal?3?5?$CFfs?6?$AA@ DB 'normal: %fs', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09OAKFDBNP@sse?3?5?$CFfs?6?$AA@
CONST	SEGMENT
??_C@_09OAKFDBNP@sse?3?5?$CFfs?6?$AA@ DB 'sse: %fs', 0aH, 00H ; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File g:\汇编语言新书实例\mmx指令\ipp_normal_add\sse_normal_mul.cpp
;	COMDAT _main
_TEXT	SEGMENT
tv212 = -308						; size = 8
tv186 = -308						; size = 8
tv211 = -300						; size = 4
tv185 = -300						; size = 4
tv266 = -296						; size = 8
tv264 = -296						; size = 8
tv256 = -292						; size = 8
tv200 = -288						; size = 8
tv174 = -288						; size = 8
tv252 = -284						; size = 8
tv244 = -284						; size = 8
tv236 = -284						; size = 8
tv199 = -280						; size = 4
tv173 = -280						; size = 4
_normal_time$ = -80					; size = 4
_i$1 = -68						; size = 4
_sse_time$ = -56					; size = 4
_i$2 = -44						; size = 4
_i$3 = -32						; size = 4
_edTime$ = -20						; size = 4
_stTime$ = -8						; size = 4
_main	PROC						; COMDAT

; 30   : int main() {

	push	ebp
	mov	ebp, esp
	sub	esp, 308				; 00000134H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-308]
	mov	ecx, 77					; 0000004dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 31   : 
; 32   : 	srand(time(NULL));

	push	0
	call	_time
	add	esp, 4
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__srand
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 33   : 
; 34   : 	clock_t stTime, edTime;
; 35   : 
; 36   : 	for (int i = 0; i < len; i++) {

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN9@main
$LN8@main:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN9@main:
	mov	eax, DWORD PTR _i$3[ebp]
	cmp	eax, DWORD PTR ?len@@3HA		; len
	jge	SHORT $LN7@main

; 37   : 		src1[i] = rand() % 100 + (rand() % 10000) * 10e-4;

	mov	esi, esp
	call	DWORD PTR __imp__rand
	cmp	esi, esp
	call	__RTC_CheckEsp
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR tv173[ebp], edx
	fild	DWORD PTR tv173[ebp]
	fstp	QWORD PTR tv174[ebp]
	fld	QWORD PTR tv174[ebp]
	mov	esi, esp
	fstp	QWORD PTR tv264[ebp]
	call	DWORD PTR __imp__rand
	cmp	esi, esp
	call	__RTC_CheckEsp
	cdq
	mov	ecx, 10000				; 00002710H
	idiv	ecx
	mov	DWORD PTR tv185[ebp], edx
	fild	DWORD PTR tv185[ebp]
	fstp	QWORD PTR tv186[ebp]
	fld	QWORD PTR tv186[ebp]
	fmul	QWORD PTR __real@3f50624dd2f1a9fc
	fadd	QWORD PTR tv264[ebp]
	mov	edx, DWORD PTR _i$3[ebp]
	fstp	DWORD PTR ?src1@@3PAMA[edx*4]

; 38   : 	}

	jmp	$LN8@main
$LN7@main:

; 39   : 	src2 = rand() % 1000 + (rand() % 10000) * 10e-4;

	mov	esi, esp
	call	DWORD PTR __imp__rand
	cmp	esi, esp
	call	__RTC_CheckEsp
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	mov	DWORD PTR tv199[ebp], edx
	fild	DWORD PTR tv199[ebp]
	fstp	QWORD PTR tv200[ebp]
	fld	QWORD PTR tv200[ebp]
	mov	esi, esp
	fstp	QWORD PTR tv266[ebp]
	call	DWORD PTR __imp__rand
	cmp	esi, esp
	call	__RTC_CheckEsp
	cdq
	mov	ecx, 10000				; 00002710H
	idiv	ecx
	mov	DWORD PTR tv211[ebp], edx
	fild	DWORD PTR tv211[ebp]
	fstp	QWORD PTR tv212[ebp]
	fld	QWORD PTR tv212[ebp]
	fmul	QWORD PTR __real@3f50624dd2f1a9fc
	fadd	QWORD PTR tv266[ebp]
	fstp	DWORD PTR ?src2@@3MA			; src2

; 40   : 	
; 41   : 	// 使用 sse 的 _mm_mul_ps 函数进行乘法操作
; 42   : 	stTime = clock();

	mov	esi, esp
	call	DWORD PTR __imp__clock
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _stTime$[ebp], eax

; 43   : 	for (int i = 0; i < epochs; i++) {

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN6@main
$LN5@main:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN6@main:
	mov	eax, DWORD PTR _i$2[ebp]
	cmp	eax, DWORD PTR ?epochs@@3HA		; epochs
	jge	SHORT $LN4@main

; 44   : 		sse_mul(src1, src2, dst, len);

	mov	eax, DWORD PTR ?len@@3HA		; len
	push	eax
	push	OFFSET ?dst@@3PAMA			; dst
	push	OFFSET ?src2@@3MA			; src2
	push	OFFSET ?src1@@3PAMA			; src1
	call	?sse_mul@@YAXPBMABMPAMH@Z		; sse_mul
	add	esp, 16					; 00000010H

; 45   : 	}

	jmp	SHORT $LN5@main
$LN4@main:

; 46   : 	edTime = clock();

	mov	esi, esp
	call	DWORD PTR __imp__clock
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _edTime$[ebp], eax

; 47   : 	int sse_time = edTime - stTime;

	mov	eax, DWORD PTR _edTime$[ebp]
	sub	eax, DWORD PTR _stTime$[ebp]
	mov	DWORD PTR _sse_time$[ebp], eax

; 48   : 
; 49   : 	// 常规的乘法
; 50   : 	stTime = clock();

	mov	esi, esp
	call	DWORD PTR __imp__clock
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _stTime$[ebp], eax

; 51   : 	for (int i = 0; i < epochs; i++) {

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@main
$LN2@main:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@main:
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR ?epochs@@3HA		; epochs
	jge	SHORT $LN1@main

; 52   : 		normal_mul(src1, src2, dst, len);

	mov	eax, DWORD PTR ?len@@3HA		; len
	push	eax
	push	OFFSET ?dst@@3PAMA			; dst
	push	OFFSET ?src2@@3MA			; src2
	push	OFFSET ?src1@@3PAMA			; src1
	call	?normal_mul@@YAXPBMABMPAMH@Z		; normal_mul
	add	esp, 16					; 00000010H

; 53   : 	}

	jmp	SHORT $LN2@main
$LN1@main:

; 54   : 	edTime = clock();

	mov	esi, esp
	call	DWORD PTR __imp__clock
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _edTime$[ebp], eax

; 55   : 	int normal_time = edTime - stTime;

	mov	eax, DWORD PTR _edTime$[ebp]
	sub	eax, DWORD PTR _stTime$[ebp]
	mov	DWORD PTR _normal_time$[ebp], eax

; 56   : 	
; 57   : 	printf("sse: %fs\n", 1.0 * sse_time / CLOCKS_PER_SEC);

	fild	DWORD PTR _sse_time$[ebp]
	fstp	QWORD PTR tv236[ebp]
	fld	QWORD PTR tv236[ebp]
	fld1
	fmulp	ST(1), ST(0)
	fdiv	QWORD PTR __real@408f400000000000
	mov	esi, esp
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_09OAKFDBNP@sse?3?5?$CFfs?6?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 58   : 	printf("normal: %fs\n", 1.0 * normal_time / CLOCKS_PER_SEC);

	fild	DWORD PTR _normal_time$[ebp]
	fstp	QWORD PTR tv244[ebp]
	fld	QWORD PTR tv244[ebp]
	fld1
	fmulp	ST(1), ST(0)
	fdiv	QWORD PTR __real@408f400000000000
	mov	esi, esp
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0N@KANIBBAJ@normal?3?5?$CFfs?6?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 59   : 	printf("normal / sse = %f", 1.0 * normal_time / sse_time);

	fild	DWORD PTR _normal_time$[ebp]
	fstp	QWORD PTR tv252[ebp]
	fld	QWORD PTR tv252[ebp]
	fld1
	fmulp	ST(1), ST(0)
	fild	DWORD PTR _sse_time$[ebp]
	fstp	QWORD PTR tv256[ebp]
	fdiv	QWORD PTR tv256[ebp]
	mov	esi, esp
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BC@DDHBBFNC@normal?5?1?5sse?5?$DN?5?$CFf?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 60   : 
; 61   : 	return 0;

	xor	eax, eax

; 62   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 308				; 00000134H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File g:\汇编语言新书实例\mmx指令\ipp_normal_add\sse_normal_mul.cpp
;	COMDAT ?normal_mul@@YAXPBMABMPAMH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_src1$ = 8						; size = 4
_src2$ = 12						; size = 4
_dst$ = 16						; size = 4
_len$ = 20						; size = 4
?normal_mul@@YAXPBMABMPAMH@Z PROC			; normal_mul, COMDAT

; 16   : void normal_mul(const float * src1, const float & src2, float * dst, int len) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 17   : 	for (int i = 0; i < len; ++i) {

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@normal_mul
$LN2@normal_mul:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@normal_mul:
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR _len$[ebp]
	jge	SHORT $LN1@normal_mul

; 18   : 		dst[i] = src1[i] * src2;

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _src1$[ebp]
	fld	DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR _src2$[ebp]
	fmul	DWORD PTR [edx]
	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _dst$[ebp]
	fstp	DWORD PTR [ecx+eax*4]

; 19   : 	}

	jmp	SHORT $LN2@normal_mul
$LN1@normal_mul:

; 20   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?normal_mul@@YAXPBMABMPAMH@Z ENDP			; normal_mul
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File g:\汇编语言新书实例\mmx指令\ipp_normal_add\sse_normal_mul.cpp
;	COMDAT ?sse_mul@@YAXPBMABMPAMH@Z
_TEXT	SEGMENT
tv69 = -312						; size = 4
$T1 = -304						; size = 16
$T2 = -272						; size = 16
_i$3 = -56						; size = 4
_len4$ = -44						; size = 4
_val$ = -32						; size = 16
_src1$ = 8						; size = 4
_src2$ = 12						; size = 4
_dst$ = 16						; size = 4
_len$ = 20						; size = 4
?sse_mul@@YAXPBMABMPAMH@Z PROC				; sse_mul, COMDAT

; 8    : void sse_mul(const float * src1, const float & src2, float * dst, int len) {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 312				; 00000138H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-312]
	mov	ecx, 78					; 0000004eH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 9    : 	__m128 val = _mm_set_ps1(src2);

	mov	eax, DWORD PTR _src2$[ebx]
	movss	xmm0, DWORD PTR [eax]
	shufps	xmm0, xmm0, 0
	movaps	XMMWORD PTR $T1[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T1[ebp]
	movaps	XMMWORD PTR _val$[ebp], xmm0

; 10   : 	int len4 = len / 4 + ((len % 4) != 0);

	mov	eax, DWORD PTR _len$[ebx]
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN8@sse_mul
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN8@sse_mul:
	test	eax, eax
	je	SHORT $LN6@sse_mul
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN7@sse_mul
$LN6@sse_mul:
	mov	DWORD PTR tv69[ebp], 0
$LN7@sse_mul:
	mov	eax, DWORD PTR _len$[ebx]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	add	eax, DWORD PTR tv69[ebp]
	mov	DWORD PTR _len4$[ebp], eax

; 11   : 	for (int i = 0; i < len4; ++i) {

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN3@sse_mul
$LN2@sse_mul:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN3@sse_mul:
	mov	eax, DWORD PTR _i$3[ebp]
	cmp	eax, DWORD PTR _len4$[ebp]
	jge	SHORT $LN1@sse_mul

; 12   : 		*(__m128 *)(dst + i * 4) = _mm_mul_ps(*(__m128 *)(src1 + i * 4), val);

	mov	eax, DWORD PTR _i$3[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR _src1$[ebx]
	movups	xmm0, XMMWORD PTR [ecx+eax*4]
	mulps	xmm0, XMMWORD PTR _val$[ebp]
	movaps	XMMWORD PTR $T2[ebp], xmm0
	mov	edx, DWORD PTR _i$3[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR _dst$[ebx]
	movups	xmm0, XMMWORD PTR $T2[ebp]
	movups	XMMWORD PTR [eax+edx*4], xmm0

; 13   : 	}

	jmp	SHORT $LN2@sse_mul
$LN1@sse_mul:

; 14   : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
?sse_mul@@YAXPBMABMPAMH@Z ENDP				; sse_mul
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\time.inl
;	COMDAT _time
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC						; COMDAT

; 132  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 133  :     return _time64(_Time);

	mov	esi, esp
	mov	eax, DWORD PTR __Time$[ebp]
	push	eax
	call	DWORD PTR __imp___time64
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 134  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_time	ENDP
_TEXT	ENDS
END
