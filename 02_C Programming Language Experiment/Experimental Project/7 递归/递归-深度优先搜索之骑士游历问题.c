#include <stdio.h>   
#include<stdlib.h>  

int n,m;/* 棋盘大小 */ 
   
int diry[]={ 2, 1, -1, -2 };  /* 跳跃的4个方向 */
int dirx[]={ 1, 2, 2, 1 };   
  
struct map {
	int x,y;
} a[100];

/************************************************************************************
函数名称：judge
函数功能：判断位置（x，y）是否在棋盘上
函数参数：x:水平方向坐标
          y：垂直方向坐标
函数返回值：在棋盘上，返回1，不在，返回0
***********************************************************************************/
int judge(int x,int y)   
{    
    if(x>0 && x<=n && y>0 && y<=m)    
        return 1;    
    else    
        return 0;    
}  
 
/************************************************************************************
函数名称：PrintResult
函数功能：输出跳跃路径
函数参数：a，指向解的指针
          n,
函数返回值：无
***********************************************************************************/
void PrintResult(struct map *a,int n)
{
	int j;
	static int count=0;
	printf("第%d条路径:",++count);
	printf("(%d,%d)",a[0].x,a[0].y);
	for(j=1;j<=n;j++)
		printf(" -> (%d,%d)",a[j].x,a[j].y);
	printf("\n");
}

/************************************************************************************
函数名称：dfs
函数功能：深度优先搜索，第i次跳跃
函数参数：i，深度
函数返回值：无
***********************************************************************************/
void dfs(int i)
{
	int j;
	for(j=0;j<4;j++)
	{
		if (judge(a[i-1].x+dirx[j],a[i-1].y+diry[j]) )  /* 跳跃点在棋盘上*/
		{     a[i].x=a[i-1].x+dirx[j];
              a[i].y=a[i-1].y+diry[j];   /* 跳跃点入栈 */
			  if((a[i].x==n) && (a[i].y==m) )  /* 跳跃点是目标节点 */
				  PrintResult(a,i);  /* 输出 */
			  dfs(i+1);   /* 深度优先搜索下一步 */
		}
	}
}

int main()   
{   
       a[0].x=1;a[0].y=1;
       scanf("%d%d",&n,&m);
       dfs(1);
	   return 0;
}