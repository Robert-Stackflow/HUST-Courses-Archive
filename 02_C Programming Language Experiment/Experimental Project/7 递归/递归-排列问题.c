/************************************************************************************
简要描述：找出从自然数1，2，…，n中任取m个数的所有排列。
*************************************************************************************/
#include<stdio.h>
void PrintPerm(int *a,int n,int m,int cur);   /*  函数原型  */

int main()
{
	int n,m;
	int a[100];
	printf("Input n:");	scanf("%d",&n);
	printf("Input m:");	scanf("%d",&m);
	PrintPerm(a,n,m,0); 
	return 0;
}

/************************************************************************************
函数名称： PrintPerm
函数功能：找出从自然数1，2，…，n中任取m个数的所有排列。
          从1～n中取一个数作为排列的第cur个元素。 
函数参数：
        a ：存放排列的数组。
        n ：自然数的个数。
        m ：选取的元素个数。
        cur：当前需要确定的元素位置。
函数返回值：无。
************************************************************************************/
void PrintPerm(int *a,int n,int m,int cur) 
{
  int i, j,count;
  if(cur==m)  /* 递归边界：已取了m个数  */ 
  { 
	 for(i=0; i<m; i++)   /* 输出这m个数构成的排列  */ 
	       printf("%d ",a[i]);
     printf("\n");
  } 
  else    /* 否则，还未取到m个数，继续取下一个  */  
	  for(i = 1; i <= n; i++)   /* 依次从1～n中取一个数给a[cur] */
	  { 
		  int ok = 1;  /* 标志变量:用于判断i之前是否已用过。1-未用过；0-用过 */
		  for(j = 0; j<cur&&ok; j++)  /*  检查i是否已用过 */ 
			  if(a[j] == i)     
				  ok = 0; /* i已经在A[0]~A[cur-1]出现过，不能再选 */
		  if(ok)   /* 未出现过 */ 
		  { 
			  a[cur] = i; /* a[cur]取i值 */ 
			  PrintPerm(a,n,m,cur+1); /* 递归调用,继续从1～n中取一个数给a[cur+1] */
		  }
	  }
}
