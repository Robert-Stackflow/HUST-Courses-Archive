/************************************************************************************
简要描述： 动态规划：0-1背包问题（使用递归方法）
*************************************************************************************/
#include<stdio.h>
#define N 5     /*  物品数   */
#define C 10   /* 背包容量     */

#define max(a,b)  ((a)>(b)?(a):(b))

int m(int i,int j);
void PrintAns(int c,int n);

int v[N+1] = {0, 6, 3, 5, 4, 6}; /* 价值，多放置一个0，是为了让下标统一，方便理解。*/
int w[N+1] = {0, 2, 2, 6, 5, 4}; /*  重量 */ 
int d[N+1][C+1];  /* 子问题最优值   */
int x[N+1];    /* 最优方案   */

int main()
{
	int j,i;
    for(i=1;i<=N;i++)           /* 将d全初始化为-1 */
        for(j=1;j<=C;j++)
			d[i][j]=-1;
    printf("最优价值：%d\n",m(1,C));    /* 输出最优价值 */
    printf("\n最优方案为：");
    PrintAns(C,N);                /* 输出方案 */
    return 0;
}

/************************************************************************************
函数名称：m
函数功能：用递归法计算子问题 “选择第i件及其后的物品放入容量为j的背包”的最优值,
          存于数组元素d[i][j]中.
函数参数：
          i:当前检索到哪个物品的序号。
		  j:当前剩余容量
函数返回值：最优解。
************************************************************************************/
int m(int i,int j)
{
	if(d[i][j]>=0)  /* 已被计算过*/
		return d[i][j];
    if(i==N) /* 最终返回点 */
		return (d[i][j]=( j>=w[i]? v[i] : 0));
	if (j < w[i]) /* 放不下第i个物品  */
		return (d[i][j]=m(i+1, j));
	return (d[i][j]=max( m(i+1,j), m(i+1, j-w[i])+v[i]));
}

/************************************************************************************
函数名称：PrintAns
函数功能：构造并输出最优方案
函数参数：
          c:背包容量。
		  n:物品数
函数返回值：无。
************************************************************************************/
void PrintAns(int c,int n)
{
    int i;
    for( i = 1; i < n; i++)
	{
       if(d[i][c]==d[i+1][c] ) x[i]=0;
       else {
            x[i]=1;
            c-=w[i];
       }
	}
    x[n]=(d[n][c]>0)?1:0;
    for( i = 1; i <= n; i++) printf("%5d",x[i]);
	printf("\n");
}

