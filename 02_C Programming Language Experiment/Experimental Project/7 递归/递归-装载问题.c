/************************************************************************************
简要描述：回溯法解装载问题。
*************************************************************************************/
#include<stdio.h>

int  n;                       /* 集装箱数             */
int  w[]={10,15,10,25,10};    /* 集装箱重量数组       */
int  c=50;                    /* 第一艘轮船的载重量   */
int  cw=0;                    /* 当前装载重量         */
int  bestw=0;                 /* 当前最大装载重量     */
int  r=0;                     /* 剩余集装箱的重量之和 */
int  *x;                      /* 指向当前解的指针     */
int  *bestx;                  /* 指向当前最优解的指针 */

void  BackTrace(int);

int main(void) 
{
	int  i;

	n=sizeof(w)/sizeof(int);
	x=(int *)malloc(n*sizeof(int));
	bestx=(int *)malloc(n*sizeof(int));
	for(i=0;i<n;i++)  /* r的初始值为所有重量之和,解空间树的每个节点上,都有唯一的r */
		r += w[i];
	BackTrace(0);   /* 找最优装载重量 */
	for(i=0;i<n;i++)  
		printf("%d\t",bestx[i]);
	printf("\n%d\n",bestw);
	return 0;
}

/************************************************************************************
函数名称：BackTrack
函数功能：使用回溯法求出装载问题的最优装载方案。
          搜索第i层结点。 
函数参数：i表示待决策的集装箱。
函数返回值：无。
************************************************************************************/	 
void BackTrace(int i)
{
	int j;
	if(i>=n)  /* 只要到了叶节点，就必定是最佳方案 */
	{  
		for (j=0;j<n;j++)  bestx[j]=x[j];
	    bestw=cw;
	    return;
	}
	r-=w[i];	  /* 无论放得下还是放不下，都减去当前货物重量 */
	if(cw+w[i]<=c)  /* 满足约束条件，即装得下当前货物,则搜索左子树, */
	{  
	    x[i]=1;
	    cw+=w[i];
	    BackTrace(i+1);
	    cw-=w[i];
	}
	if(cw+r>bestw)  /* 满足上界函数，搜索右子树  */
	{  
	    x[i]=0;
	    BackTrace(i+1);
	}
	r+=w[i];  /* 恢复当前货物重量的值，退回准备从更高层去遍历 */
}